<!--

/*
** Copyright (c) 2015 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>WebGL 2 ReadPixels Test.</title>
<link rel="stylesheet" href="../../resources/js-test-style.css"/>
<script src="../../js/js-test-pre.js"></script>
<script src="../../js/webgl-test-utils.js"> </script>
</head>
<body>
<div id="description"></div>
<div id="console"></div>
<script>
"use strict";
description("Checks that ReadPixels from a fbo works as expected.");

var wtu = WebGLTestUtils;
var gl = wtu.create3DContext();

function r(buf, index, expectedColor, tol) {
  var color = [buf[index], buf[index + 1], buf[index + 2], buf[index + 3]];
  if (Math.abs(color[0] - expectedColor[0]) > tol[0]) {
    testFailed("Expected red = " + expectedColor + ", was = " + color);
    return false;
  }
  return true;
}

function rg(buf, index, expectedColor, tol) {
  var color = [buf[index], buf[index + 1], buf[index + 2], buf[index + 3]];
  if (Math.abs(color[0] - expectedColor[0]) > tol[0] ||
      Math.abs(color[1] - expectedColor[1]) > tol[1]) {
    testFailed("Expected rg = " + expectedColor + ", was = " + color);
    return false;
  }
  return true;
}

function rgb(buf, index, expectedColor, tol) {
  var color = [buf[index], buf[index + 1], buf[index + 2], buf[index + 3]];
  if (Math.abs(color[0] - expectedColor[0]) > tol[0] ||
      Math.abs(color[1] - expectedColor[1]) > tol[1] ||
      Math.abs(color[2] - expectedColor[2]) > tol[2]) {
    testFailed("Expected rgb = " + expectedColor + ", was = " + color);
    return false;
  }
  return true;
}

function rgba(buf, index, expectedColor, tol) {
  var color = [buf[index], buf[index + 1], buf[index + 2], buf[index + 3]];
  if (Math.abs(color[0] - expectedColor[0]) > tol[0] ||
      Math.abs(color[1] - expectedColor[1]) > tol[1] ||
      Math.abs(color[2] - expectedColor[2]) > tol[2] ||
      Math.abs(color[3] - expectedColor[3]) > tol[3]) {
    testFailed("Expected rgba = " + expectedColor + ", was = " + color);
    return false;
  }
  return true;
}

function r10g10b10a2_int32(buf, index, expectedColor, tol) {
  var r = (buf[index] & 0x3FF);
  var g = ((buf[index] >> 10) & 0x3FF);
  var b = ((buf[index] >> 20) & 0x3FF);
  var a = (buf[index] >> 30);
  var color = [r, g, b, a];
  if (Math.abs(color[0] - expectedColor[0]) > tol[0] ||
      Math.abs(color[1] - expectedColor[1]) > tol[1] ||
      Math.abs(color[2] - expectedColor[2]) > tol[2] ||
      Math.abs(color[3] - expectedColor[3]) > tol[3]) {
    testFailed("Expected rgba = " + expectedColor + ", was = " + color);
    return false;
  }
  return true;
}

var textureTestCases = [
  {
    texInternalFormat: 'R8', texFormat: 'RED', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0.0, 0.0, 0], readBackColor: [127, 0, 0, 0], tol: [3, 0, 0, 0],
    colorCheckFunc: r
  },
  {
    texInternalFormat: 'R8I', texFormat: 'RED_INTEGER', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [250, 0, 0, 0], readBackColor: [250, 0, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: r
  },
  {
    texInternalFormat: 'R8I', texFormat: 'RED_INTEGER', texType: 'BYTE',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [-250, 0, 0, 0], readBackColor: [-250, 0, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: r
  },
  {
    texInternalFormat: 'R16UI', texFormat: 'RED_INTEGER', texType: 'UNSIGNED_SHORT',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [30001, 0, 0, 0], readBackColor: [30001, 0, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: r
  },
  {
    texInternalFormat: 'R16I', texFormat: 'RED_INTEGER', texType: 'SHORT',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [-14189, 0, 0, 0], readBackColor: [-14189, 0, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: r
  },
  {
    texInternalFormat: 'R32UI', texFormat: 'RED_INTEGER', texType: 'UNSIGNED_INT',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [126726, 0, 0, 0], readBackColor: [126726, 0, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: r
  },
  {
    texInternalFormat: 'R32I', texFormat: 'RED_INTEGER', texType: 'INT',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [-126726, 0, 0, 0], readBackColor: [-126726, 0, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: r
  },

  {
    texInternalFormat: 'RG8', texFormat: 'RG', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0.7, 0.0, 0], readBackColor: [127, 178, 0, 0], tol: [3, 3, 0, 0],
    colorCheckFunc: rg
  },
  {
    texInternalFormat: 'RG8UI', texFormat: 'RG_INTEGER', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [250, 124, 0, 0], readBackColor: [250, 124, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: rg
  },
  {
    texInternalFormat: 'RG8I', texFormat: 'RG_INTEGER', texType: 'BYTE',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [-55, 124, 0, 0], readBackColor: [-55, 124, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: rg
  },
  {
    texInternalFormat: 'RG16UI', texFormat: 'RG_INTEGER', texType: 'UNSIGNED_SHORT',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [30001, 18, 0, 0], readBackColor: [30001, 18, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: rg
  },
  {
    texInternalFormat: 'RG16I', texFormat: 'RG_INTEGER', texType: 'SHORT',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [-14189, 6735, 0, 0], readBackColor: [-14189, 6735, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: rg,
  },
  {
    texInternalFormat: 'RG32UI', texFormat: 'RG_INTEGER', texType: 'UNSIGNED_INT',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [126726, 1976, 0, 0], readBackColor: [126726, 1976, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: rg
  },
  {
    texInternalFormat: 'RG32I', texFormat: 'RG_INTEGER', texType: 'INT',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [-126726, 126726, 0, 0], readBackColor: [-126726, 126726, 0, 0], tol: [0, 0, 0, 0],
    colorCheckFunc: rg
  },

  {
    texInternalFormat: 'RGB8', texFormat: 'RGB', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 1, 0, 0], readBackColor: [127, 255, 0, 0], tol: [3, 0, 0, 0],
    colorCheckFunc: rgb
  },
  {
    texInternalFormat: 'RGB565', texFormat: 'RGB', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0.7, 0.2, 0], readBackColor: [127, 178, 51, 0], tol: [17, 9, 17, 0],
    colorCheckFunc: rgb
  },
  {
    texInternalFormat: 'RGB565', texFormat: 'RGB', texType: 'UNSIGNED_SHORT_5_6_5',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0.7, 0.2, 0], readBackColor: [127, 178, 51, 0], tol: [17, 9, 17, 0],
    colorCheckFunc: rgb
  },

  {
    texInternalFormat: 'RGBA8', texFormat: 'RGBA', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0, 1, 0.7], readBackColor: [127, 0, 255, 178], tol: [3, 0, 0, 3],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'SRGB8_ALPHA8', texFormat: 'RGBA', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0, 1, 0.7], readBackColor: [127, 0, 255, 178], tol: [3, 0, 0, 3],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGB5_A1', texFormat: 'RGBA', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0, 0.7, 1], readBackColor: [127, 0, 178, 255], tol: [17, 0, 17, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGB5_A1', texFormat: 'RGBA', texType: 'UNSIGNED_SHORT_5_5_5_1',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0.7, 1, 0], readBackColor: [127, 178, 255, 0], tol: [17, 17, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGB5_A1', texFormat: 'RGBA', texType: 'UNSIGNED_INT_2_10_10_10_REV',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0.7, 0, 1], readBackColor: [127, 178, 0, 255], tol: [17, 17, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGBA4', texFormat: 'RGBA', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.5, 0.7, 1, 0], readBackColor: [127, 178, 255, 0], tol: [34, 34, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGBA4', texFormat: 'RGBA', texType: 'UNSIGNED_SHORT_4_4_4_4',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [1, 0, 0.5, 0.7], readBackColor: [255, 0, 127, 178], tol: [0, 0, 34, 34],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGB10_A2', texFormat: 'RGBA', texType: 'UNSIGNED_INT_2_10_10_10_REV',
    readFormat: 'RGBA', readType: 'UNSIGNED_BYTE',
    clearColor: [0.7, 0, 0.5, 1], readBackColor: [178, 0, 127, 255], tol: [1, 0, 1, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGB10_A2', texFormat: 'RGBA', texType: 'UNSIGNED_INT_2_10_10_10_REV',
    readFormat: 'RGBA', readType: 'UNSIGNED_INT_2_10_10_10_REV',
    clearColor: [1, 0.5, 0.7, 1], readBackColor: [1023, 511, 716, 3], tol: [1, 1, 1, 0],
    colorCheckFunc: r10g10b10a2_int32
  },
  {
    texInternalFormat: 'RGBA8UI', texFormat: 'RGBA_INTEGER', texType: 'UNSIGNED_BYTE',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [127, 0, 255, 178], readBackColor: [127, 0, 255, 178], tol: [0, 0, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGBA8I', texFormat: 'RGBA_INTEGER', texType: 'BYTE',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [-55, 56, 80, 127], readBackColor: [-55, 56, 80, 127], tol: [0, 0, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGB10_A2UI', texFormat: 'RGBA_INTEGER', texType: 'UNSIGNED_INT_2_10_10_10_REV',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [178, 0, 127, 255], readBackColor: [178, 0, 127, 255], tol: [0, 0, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGBA16UI', texFormat: 'RGBA_INTEGER', texType: 'UNSIGNED_SHORT',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [14189, 6735, 0, 19], readBackColor: [14189, 6735, 0, 19], tol: [0, 0, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGBA16I', texFormat: 'RGBA_INTEGER', texType: 'SHORT',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [14189, -6735, 0, 19], readBackColor: [14189, -6735, 0, 19], tol: [0, 0, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGBA32UI', texFormat: 'RGBA_INTEGER', texType: 'UNSIGNED_INT',
    readFormat: 'RGBA_INTEGER', readType: 'UNSIGNED_INT',
    clearColor: [126726, 6726, 98765, 2015], readBackColor: [126726, 6726, 98765, 2015], tol: [0, 0, 0, 0],
    colorCheckFunc: rgba
  },
  {
    texInternalFormat: 'RGBA32I', texFormat: 'RGBA_INTEGER', texType: 'INT',
    readFormat: 'RGBA_INTEGER', readType: 'INT',
    clearColor: [126726, -6726, -98765, 2015], readBackColor: [126726, -6726, -98765, 2015], tol: [0, 0, 0, 0],
    colorCheckFunc: rgba
  },
  // TODO(zmo): add float/half_float test cases with extension supports.
];

function getArrayTypeFromReadPixelsType(gl, type) {
  switch (type) {
    case gl.UNSIGNED_BYTE:
      return Uint8Array;
    case gl.BYTE:
      return Int8Array;
    case gl.UNSIGNED_SHORT:
    case gl.UNSIGNED_SHORT_5_6_5:
    case gl.UNSIGNED_SHORT_4_4_4_4:
    case gl.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case gl.SHORT:
      return Int16Array;
    case gl.UNSIGNED_INT:
    case gl.UNSIGNED_INT_2_10_10_10_REV:
    case gl.UNSIGNED_INT_10F_11F_11F_REV:
    case gl.UNSIGNED_INT_5_9_9_9_REV:
      return Uint32Array;
    case gl.INT:
      return Int32Array;
    case gl.HALF_FLOAT:
      return Uint16Array;
    case gl.FLOAT:
      return Float32Array;
    default:
      return null;
  }
}

function getFormatString(gl, format) {
  switch (format) {
    case gl.RED:
      return 'RED';
    case gl.RED_INTEGER:
      return 'RED_INTEGER';
    case gl.RG:
      return 'RG';
    case gl.RG_INTEGER:
      return 'RG_INTEGER';
    case gl.RGB:
      return 'RGB';
    case gl.RGB_INTEGER:
      return 'RGB_INTEGER';
    case gl.RGBA:
      return 'RGBA';
    case gl.RGBA_INTEGER:
      return 'RGBA_INTEGER';
    case gl.LUMINANCE:
      return 'LUMINANCE';
    case gl.LUMINANCE_ALPHA:
      return 'LUMINANCE_ALPHA';
    case gl.ALPHA:
      return 'ALPHA';
    default:
      return '';
  };
}

function getTypeString(gl, type) {
  switch (type) {
    case gl.UNSIGNED_BYTE:
      return 'UNSIGNED_BYTE';
    case gl.BYTE:
      return 'BYTE';
    case gl.UNSIGNED_SHORT:
      return 'UNSIGNED_SHORT';
    case gl.SHORT:
      return 'SHORT';
    case gl.UNSIGNED_INT:
      return 'UNSIGNED_INT';
    case gl.INT:
      return 'INT';
    case gl.UNSIGNED_SHORT_5_6_5:
      return 'UNSIGNED_SHORT_5_6_5';
    case gl.UNSIGNED_SHORT_4_4_4_4:
      return 'UNSIGNED_SHORT_4_4_4_4';
    case gl.UNSIGNED_SHORT_5_5_5_1:
      return 'UNSIGNED_SHORT_5_5_5_1';
    case gl.UNSIGNED_INT_2_10_10_10_REV:
      return 'UNSIGNED_INT_2_10_10_10_REV';
    case gl.UNSIGNED_INT_10F_11F_11F_REV:
      return 'UNSIGNED_INT_10F_11F_11F_REV';
    case gl.UNSIGNED_INT_5_9_9_9_REV:
      return 'UNSIGNED_INT_5_9_9_9_REV';
    default:
      return '';
  };
}

function testReadPixels(gl, readFormat, readType, expectedColor, tol, colorCheckFunc) {
  var arrayType = getArrayTypeFromReadPixelsType(gl, readType);
  var buf = new arrayType(width * height * 4);
  gl.readPixels(0, 0, width, height, readFormat, readType, buf);
  wtu.glErrorShouldBe(
      gl, gl.NO_ERROR, "readPixels should generate no error");
  var diffFound = false;
  for (var ii = 0; ii < width * height; ++ii) {
    var offset = ii * 4;
    if (!colorCheckFunc(buf, offset, expectedColor, tol)) {
      diffFound = true;
      break;
    }
  }
  if (!diffFound) {
    testPassed("Color read back as expected");
  }
}

function clearBuffer(gl, texInternalFormat, clearColor) {
  var value;
  switch (texInternalFormat) {
    case gl.R8UI:
    case gl.R16UI:
    case gl.R32UI:
    case gl.RG8UI:
    case gl.RG16UI:
    case gl.RG32UI:
    case gl.RGBA8UI:
    case gl.RGBA16UI:
    case gl.RGBA32UI:
    case gl.RGB10_A2UI:
      value = new Uint32Array(4);
      for (var ii = 0; ii < 4; ++ii)
        value[ii] = clearColor[ii];
      gl.clearBufferuiv(gl.COLOR, 0, value);
      break;
    case gl.R8I:
    case gl.R16I:
    case gl.R32I:
    case gl.RG8I:
    case gl.RG16I:
    case gl.RG32I:
    case gl.RGBA8I:
    case gl.RGBA16I:
    case gl.RGBA32I:
      value = new Int32Array(4);
      for (var ii = 0; ii < 4; ++ii)
        value[ii] = clearColor[ii];
      gl.clearBufferiv(gl.COLOR, 0, clearColor);
      break;
    default:
      gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
      gl.clear(gl.COLOR_BUFFER_BIT);
      break;
  }
}

for (var tt = 0; tt < textureTestCases.length; ++tt) {
  var test = textureTestCases[tt];
  debug("");
  debug("ReadPixels from fbo with texture = (" + test.texInternalFormat +
        ", " + test.texFormat + ", " + test.texType +
        "), format = " + test.readFormat + ", type = " + test.readType);
  var width = 2;
  var height = 2;
  var fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  var colorImage = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, colorImage);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl[test.texInternalFormat], width, height, 0,
                gl[test.texFormat], gl[test.texType], null);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                          gl.TEXTURE_2D, colorImage, 0);
  wtu.glErrorShouldBe(
      gl, gl.NO_ERROR, "Setting up fbo should generate no error");
  if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
    debug("fbo is not complete, skip");
    continue;
  }
  clearBuffer(gl, gl[test.texInternalFormat], test.clearColor);
  wtu.glErrorShouldBe(
      gl, gl.NO_ERROR, "Clear color should generate no error");
  testReadPixels(gl, gl[test.readFormat], gl[test.readType],
                 test.readBackColor, test.tol, test.colorCheckFunc);

  var implFormat = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);
  var implType = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);
  var implFormatString = getFormatString(gl, implFormat);
  var implTypeString = getTypeString(gl, implType);
  debug("Testing implementation dependent color read format = " + implFormatString +
        ", type = " + implTypeString);
  if (implFormatString == '') {
    testFailed("Invalid IMPLEMENTATION_COLOR_READ_FORMAT = " + implFormat);
    continue;
  }
  if (implTypeString == '') {
    testFailed("Invalid IMPLEMENTATION_COLOR_READ_TYPE = " + implType);
    continue;
  }
  testReadPixels(gl, implFormat, implType,
                 test.readBackColor, test.tol, test.colorCheckFunc);

  gl.deleteTexture(colorImage);
  gl.deleteFramebuffer(fbo);
}

debug("")
var successfullyParsed = true;
</script>
<script src="../../js/js-test-post.js"></script>
</body>
</html>

